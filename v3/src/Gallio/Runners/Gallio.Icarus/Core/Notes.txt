DON'T DELETE, NOTES FOR ANDY

Okay.  Create an AutoTestRunner.
Or, if you've already got an IRuntime object hanging around (and you should if you're using IoC in Icarus) then just make a BaseTestRunner or derive something else of your own creation.
Build up a TestPackage with a list of assembly filenames and other options such as the Application Base directory.  Many of these options will only be relevant to 1% of users btw.
Then ask the test runner to LoadPackage the package.
This causes the assemblies to be loaded into an isolated app-domain (by default anyways).
If it succeeds, you know you've loaded everything fine.
Otherwise the exception will explain what went wrong.

For UI purposes we will probably want to expand on the error reporting mechanism somehow.
In any case you get progress monitoring while the package is being loaded so the user can understand what's going on and cancel out if it takes too long to load everything up for example.
Progress monitoring makes a huge difference in the perceived responsiveness of an app.

Next step is to build the templates.  So you call BuildTemplates and do that.
In the future there will be TemplateBuilderOptions to control this process.  Don't worry about it just now.
Then you build the tests.  Call BuildTests.  Same deal as before.

Once this is done you'll have a TestModel you can play with.
Note that Icarus can also play with the TemplateModel and there will be useful things we can do with that.
Right now it's not so important, but when I finalize the story on parameterized test assemblies it'll become useful to have this phase separated out.
The idea is that Icarus might look at the TemplateModel to figure out what parameters are needed.  Then after prompting the user for them or otherwise obtaining the necessary values, it will set them in the TestBuilderOptions and finally call BuildTests.
For now it's ok if the template model is hidden from the user.  Later on we should provide a tab to display it and perform various actions with it.

A TestModel contains a tree of TestInfo objects. 
Everything you need to display a test tree in Icarus is in there.
For example, to decide what kind of icon to display for a given node in the tree, you can check whether it has the MetadataConstants.KindKey metadata associated with it and then map the values you recognize to particular icons.

The dictionary is to help you map ids to nodes.
Test events refer to nodes in the tree by id rather than by passing a TestInfo object, so you can look them up in the dictionary.
That isn't quite the whole story for tests but it's a good start.  Eventually there will be support for dynamically generated tests at runtime.  
They won't appear in the test tree when tests are enumerated.  However, when tests are executed they will show up as new dynamic children of known tests.
This is intended to support things like load testing where we might run a random assortment of tests for a specified duration.  So we won't know ahead of time how many iterations of each test we will run.  Each iteration will appear as a new "dynamic" test created at runtime.

TestModel holds the root TestInfo, each TestInfo is recursive for the next (Array of TestInfo).

using (progressMonitor)
{
    progressMonitor.BeginTask("Loading...", 10);

    Step1(new SubProgressMonitor(progressMonitor, 2);
    Step2(new SubProgressMonitor(progressMonitor, 7);
    Step3(new SubProgressMonitor(progressMonitor, 1);
}