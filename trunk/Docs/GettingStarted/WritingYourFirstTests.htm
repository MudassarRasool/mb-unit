<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
   <title>Writing Your First Tests</title>
   <style type="text/css">
   .csharpcode, .csharpcode pre
   {
	   font-size: small;
	   color: black;
	   font-family: "Courier New", courier, monospace;
	   background-color: #ffffff;
	   /*white-space: pre;*/
   }
   .csharpcode pre { margin: 0em; }
   .csharpcode .rem { color: #008000; }
   .csharpcode .kwrd { color: #0000ff; }
   .csharpcode .str { color: #006080; }
   .csharpcode .op { color: #0000c0; }
   .csharpcode .preproc { color: #cc6633; }
   .csharpcode .asp { background-color: #ffff00; }
   .csharpcode .html { color: #800000; }
   .csharpcode .attr { color: #ff0000; }
   .csharpcode .alt 
   {
   	background-color: #f4f4f4;
   	width: 100%;
   	margin: 0em;
   }
   .csharpcode .lnum { color: #606060; }
   </style>
</head>
<body>
   <h1>
      Writing your first tests</h1>
   <p>
      Writing tests for your code isn&#8217;t difficult. It&#8217;s simply a matter of
      <em>fixtures, tests and asserts</em>.</p>
   <ul>
      <li>An <em>assert</em> is a simple check. For example, that an integer is less than
         another, that a variable is of a given type, or that a value in a database is the
         expected one. The idea of asserts in .NET is not a new one, but in unit testing,
         an assert is the most basic ingredient of the development process. MbUnit pre-defines
         a lot of different asserts so you don't have to. It also leaves you free to build
         your own as you need to.</li>
      <li>A test is a collection of asserts intended to prove that an action or series of
         actions in your production code actually does what you think it does. For example,
         that your SaveToDB() method has actually saved information to your database correctly,
         that your Add() method really does add those values together or that the default
         constructor for your class doesn't create a null object.</li>
      <li>A fixture is a collection of tests usually related to a single class in your production
         code. It doesn&#8217;t have to be, but that&#8217;s usually how it turns out.</li>
   </ul>
   <p>
      With that knowledge in your head, let&#8217;s write a few tests for an application
      to help you win at the classic fizzbuzz game. The rules are easy.</p>
   <ul>
      <li>If a number is wholly divisible by 3, return the word fizz.</li>
      <li>If a number is wholly divisible by 5, return the word buzz.</li>
      <li>If a number is wholly divisible by 3 and 5, return the word fizzbuzz.</li>
      <li>If a number isn't wholly divisible by either or 5, return the number.</li>
   </ul>
   <p>
      To keep things simple, we&#8217;ll just create a simple static method called ToFizzBuzz()
      that takes an integer as an argument and returns the correct fizzbuzz string.</p>
   <h2>
      Setting Up The Solution</h2>
   <p>
      There are two options when it comes to organising your test code in your solution
   </p>
   <ul>
      <li>You can write your tests in the same project as the code you are testing, <a
         href="http://beta.mbunit.com/GettingStarted.aspx">as demonstrated over on our main
         site</a>.</li>
      <li>You can keep your tests in a separate assembly from the code you are testing, which
         we'll demonstrate here. It takes a bit longer to set up but does mean your test
         code won't be included in any live code your release.</li>
   </ul>
   <p>
      First you&#8217;ll need to create two projects, one for the production code containing
      ToFizzBuzz() and one for the test code.</p>
   <ol>
      <li>Open up Visual Studio and create a new c# class library solution. We've called
         it FizzBuzz and renamed class1.cs to fizzbuzz.cs .</li>
      <li>Once it has been created, add another c# class library project to the solution
         called FizzbuzzTests and renamed class1.cs to fizzbuzztests.cs.</li>
      <li>Add a reference to MbUnit.Framework.dll to the FizzBuzzTests project. You'll find
         it in the .NET tab.<br />
         <a href="../Images/FirstTests[1].Png" target="_blank" title="Enlarge Image">
            <img alt="Adding MbUnit as a reference in VS" src="../images/FirstTests[1]thumbnail.Png" /></a>
         <br />
      </li>
      <li>You'll also need to add a reference to the FizzBuzz project to FizzBuzzTests.</li>
      <li>Solution explorer should now look something like this<br />
         <img alt="Your solution setup ready for writing tests" src="../images/FirstTests[2].Png" />
      </li>
   </ol>
   <p>
      That's you all set up. Now all you need to do are write tests and some code.</p>
   <h2>
      Writing the Tests</h2>
   <p>
      With the project setup, writing the tests is straightforward.</p>
   <ul>
      <li>First, add a couple of using statements to the top of the test class; one for MbUnit.Framework
         so our tests will compile and one for the FizzBuzz class we're testing</li>
      <li>Next, you need to define a test fixture. Recall from above that a fixture is a
         collection of tests defined in a class. To do that, we decorate the FizzBuzzTests
         class with the [TestFixture] attribute. Easy. Your code should now look like this.<br />
         <br />
         <div class="csharpcode">
            <pre><span class="lnum">1: </span><span class="kwrd">using</span> System;</pre>
            <pre><span class="lnum">2: </span><span class="kwrd">using</span> FizzBuzz;</pre>
            <pre><span class="lnum">3: </span><span class="kwrd">using</span> MbUnit.Framework;</pre>
            <pre><span class="lnum">4: </span>&nbsp;</pre>
            <pre><span class="lnum">5: </span><span class="kwrd">namespace</span> FizzBuzzTests</pre>
            <pre><span class="lnum">6: </span>{</pre>
            <pre><span class="lnum">7: </span>   [TestFixture]</pre>
            <pre><span class="lnum">8: </span>   <span class="kwrd">public</span> <span class="kwrd">class</span> FizzBuzzTests</pre>
            <pre><span class="lnum">9: </span>   {</pre>
            <pre><span class="lnum">10: </span>  }</pre>
            <pre><span class="lnum">11: </span>}</pre>
            <br />
         </div>
      </li>
      <li>Tests should always be written before writing code. So we start by making sure
         that ToFizzBuzz() will return &#8220;1&#8221; when given the number 1 with the following
         test.<br />
         <br />
         <div class="csharpcode">
            <pre><span class="lnum">10: </span>[Test]</pre>
            <pre><span class="lnum">11: </span><span class="kwrd">public</span> <span class="kwrd">void</span> ToFizzBuzz_Send1_Returns1()</pre>
            <pre><span class="lnum">12: </span>{</pre>
            <pre><span class="lnum">13: </span>   Assert.AreEqual(<span class="str">"1"</span>, FizzBuzz.FizzBuzz.ToFizzBuzz(1));</pre>
            <pre><span class="lnum">14: </span>}</pre>
            <br />
         </div>
         As you can see, we have one assert in this test: that ToFizzBuzz() returns "1" when we send it the integer 1.
      </li>
      <li>Now we run the test to make sure that it fails. We can do this with either the
         <a href="MbUnitConsoleRunner.htm">console test runner</a>, <a href="MbUnitGUI.htm">
            the GUI runner</a>, or another third party test runner such as <a href="../MbUnitAndVisualStudio/MbUnitAndTestDrivenDotNet.htm">
               TestDriven.NET</a> or <a href="../MbUnitAndVisualStudio/MbUnitAndResharper.htm">Resharper</a>.
         The choice is yours. Follow the links to see how to run the tests. </li>
      <li>Now to write the simplest code that satisfies the test. Thus we have.<br />
         <br />
         <div class="csharpcode">
<pre><span class="lnum">1:  </span><span class="kwrd">using</span> System;</pre>
<pre><span class="lnum">2:  </span>&nbsp;</pre>
<pre><span class="lnum">3:  </span><span class="kwrd">namespace</span> FizzBuzz</pre>
<pre><span class="lnum">4:  </span>{</pre>
<pre><span class="lnum">5:  </span>   <span class="kwrd">public</span> <span class="kwrd">class</span> FizzBuzz</pre>
<pre><span class="lnum">6:  </span>   {</pre>
<pre><span class="lnum">7:  </span>      <span class="kwrd">public</span> <span class="kwrd">static</span> <span class="kwrd">string</span> ToFizzBuzz(<span class="kwrd">int</span> number)</pre>
<pre><span class="lnum">8:  </span>      {</pre>
<pre><span class="lnum">9:  </span>         <span class="kwrd">return</span> <span class="str">"1"</span>;</pre>
<pre><span class="lnum">10:  </span>      }</pre>
<pre><span class="lnum">11:  </span>   }</pre>
<pre><span class="lnum">12:  </span>}</pre>
<br />
</div>
      </li>
      <li>
         And so the cycle continues. Our next test should be for the number 2. We could write another test called ToFizzBuzz_Send2_Returns2() which basically copies everything in the previous test except for replacing 1s with 2s. However, the key to refactor everywhere if possible applies to our test code, and we can make use of MbUnit's excellent RowTest facility and generalise the test we have for all numbers which aren't divisible by 3 or 5.<br />
         <br />
         <div class="csharpcode">
<pre><span class="lnum">10:  </span>      [Row(1)]</pre>
<pre><span class="lnum">11:  </span>      [Row(2)]</pre>
<pre><span class="lnum">12:  </span>      [RowTest]</pre>
<pre><span class="lnum">13:  </span>      <span class="kwrd">public</span> <span class="kwrd">void</span> ToFizzBuzz_SendNumberNotDivisibleBy3Or5_ReturnsNumberAsString(<span class="kwrd">int</span> NumberToTest)</pre>
<pre><span class="lnum">14:  </span>      {</pre>
<pre><span class="lnum">15:  </span>         Assert.AreEqual(NumberToTest.ToString(), </pre>
<pre><span class="lnum">16:  </span>            FizzBuzz.FizzBuzz.ToFizzBuzz(NumberToTest));</pre>
<pre><span class="lnum">17:  </span>      }</pre>
<br /></div>
It&#8217;s not the catchiest name, but it explains exactly what the test is testing (ToFizzBuzz), how it is being tested (sending it a number which isn't divisible by three or five), and the result it expects (returning the number as a string). The [RowTest] attribute which has replaced [Test] tells MbUnit that this test must be performed using the different values in each row given above [RowTest]. Those values are plugged into the test as parameters - int NumberToTest, in this case - so MbUnit now runs our test twice, once to test ToFizzBuzz() with the number 1 and again with the number 2. If you run the test again, you'll see it succeed once (with the number 1) and fail once (against the number 2). 
      </li>
      <li>
         To make both tests succeed, we need to make just a slight alteration to ToFizzBuzz()<br />
         <br />
         <div class="csharpcode">
<pre><span class="lnum"> 7:  </span>      <span class="kwrd">public</span> <span class="kwrd">static</span> <span class="kwrd">string</span> ToFizzBuzz(<span class="kwrd">int</span> number)</pre>
<pre><span class="lnum"> 8:  </span>      {</pre>
<pre><span class="lnum"> 9:  </span>         <span class="kwrd">return</span> number.ToString();</pre>
<pre><span class="lnum">10:  </span>      }</pre><br />
</div>
      </li>
      <li>
         And so we continue the cycle of writing tests and then writing the code that satisfies them. There are three more tests to write for ToFizzBuzz.
         <ul>
            <li>Sending it a multiple of 3 but not of 15 and it returning "fizz"</li>
            <li>Sending it a multiple of 5 but not of 15 and it returning "buzz"</li>
            <li>Sending it a multiple of 15 and it returning "fizzbuzz"</li>
         </ul>
         The first might look something like the following. <br />
         <br />
         <div class="csharpcode">
<pre><span class="lnum">19:  </span>      [Row(3)]</pre>
<pre><span class="lnum">20:  </span>      [Row(6)]</pre>
<pre><span class="lnum">21:  </span>      [RowTest]</pre>
<pre><span class="lnum">22:  </span>      <span class="kwrd">public</span> <span class="kwrd">void</span> ToFizzBuzz_SendNumberDivisibleBy3ButNot5_ReturnsFizz(<span class="kwrd">int</span> NumberToTest)</pre>
<pre><span class="lnum">23:  </span>      { </pre>
<pre><span class="lnum">24:  </span>         Assert.AreEqual(<span class="str">"fizz"</span>, FizzBuzz.FizzBuzz.ToFizzBuzz(NumberToTest));</pre>
<pre><span class="lnum">25:  </span>      }</pre>
<br /></div>
      </li>
   </ul>
   <p>And so on. The point here is not how to write the best implementation of ToFizzBuzz() - there are several equally good ones - but that writing tests is not any different from writing another piece of code. The key is that your tests must be correct before your code can be. If we added [Row(15)] to this latest test, it would expect ToFizzBuzz() to return "fizz" rather than "fizzbuzz" as it should.</p>
   <p>What MbUnit provides you with are methods such as the row test to let you perform these tests with the minimum of coding required. To that extent, the MbUnit.Framework library offers a great number of asserts for checking values, arrays, collections, data, files and more for you to use and a number of different test types in addition to the vanilla [Test] and strawberry flavoured [RowTest] you've seen here. All of these are covered in our <a href="../api.htm">API reference</a> in detail. If you're not sure what to start, perhaps you should check out <a href="../WhatDoYouWantToTest.htm">this rough guide</a>.</p>
   <h2>More Step by Step guides</h2>
   <p>Check out our <a href="http://www.mbunit.com/articles.aspx">articles page</a> for more step by step guides to writing code using tests.</p>
</body>
</html>
